@inproceedings{Dijkstra:SOSP:1967,
  author = {Edsger W. Dijkstra},
  title = "{The Structure of the ``THE'' Multiprogramming System}",
  booktitle = {Proceedings of the 1st ACM Symposium on Operating System Principles (SOSP'67)},
  year = {1967},
  month = OCT,
}

@misc{k8s,
  title = "{Kubernetes}",
  howpublished = {\url{https://kubernetes.io/}},
  year = {2024}
}

@inproceedings{Kadav:2012,
  author = {Kadav, Asim and Swift, Michael M.},
  title = {Understanding modern device drivers},
  year = {2012},
  isbn = {9781450307598},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2150976.2150987},
  doi = {10.1145/2150976.2150987},
  abstract = {Device drivers are the single largest contributor to operating-system kernel code with over 5 million lines of code in the Linux kernel, and cause significant complexity, bugs and development costs. Recent years have seen a flurry of research aimed at improving the reliability and simplifying the development of drivers. However, little is known about what constitutes this huge body of code beyond the small set of drivers used for research.In this paper, we study the source code of Linux drivers to understand what drivers actually do, how current research applies to them and what opportunities exist for future research. We determine whether assumptions made by most driver research, such as that all drivers belong to a class, are indeed true. We also analyze driver code and abstractions to determine whether drivers can benefit from code re-organization or hardware trends. We develop a set of static-analysis tools to analyze driver code across various axes. Broadly, our study looks at three aspects of driver code (i) what are the characteristics of driver code functionality and how applicable is driver research to all drivers, (ii) how do drivers interact with the kernel, devices, and buses, and (iii) are there similarities that can be abstracted into libraries to reduce driver size and complexity?We find that many assumptions made by driver research do not apply to all drivers. At least 44\% of drivers have code that is not captured by a class definition, 28\% of drivers support more than one device per driver, and 15\% of drivers do significant computation over data. From the driver interactions study, we find USB bus offers an efficient bus interface with significant standardized code and coarse-grained access, ideal for executing drivers in isolation. We also find that drivers for different buses and classes have widely varying levels of device interaction, which indicates that the cost of isolation will vary by class. Finally, from our driver similarity study, we find 8\% of all driver code is substantially similar to code elsewhere and may be removed with new abstractions or libraries.},
  booktitle = {Proceedings of the Seventeenth International Conference on Architectural Support for Programming Languages and Operating Systems},
  pages = {87â€“98},
  numpages = {12},
  keywords = {measurement, device drivers},
  location = {London, England, UK},
  series = {ASPLOS XVII}
}

@inproceedings {Sun:2022,
  author = {Xudong Sun and Wenqing Luo and Jiawei Tyler Gu and Aishwarya Ganesan and Ramnatthan Alagappan and Michael Gasch and Lalith Suresh and Tianyin Xu},
  title = {Automatic Reliability Testing For Cluster Management Controllers},
  booktitle = {16th USENIX Symposium on Operating Systems Design and Implementation (OSDI 22)},
  year = {2022},
  isbn = {978-1-939133-28-1},
  address = {Carlsbad, CA},
  pages = {143--159},
  url = {https://www.usenix.org/conference/osdi22/presentation/sun},
  publisher = {USENIX Association},
  month = jul
}
